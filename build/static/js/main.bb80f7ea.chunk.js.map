{"version":3,"sources":["logic/maze/Random.js","logic/AlgorithmManager.js","logic/maze/Prim.js","logic/maze/DFS.js","logic/solvers/BFS.js","logic/solvers/DFS.js","logic/GraphLogic.js","logic/redux/reducers/reducers.js","logic/redux/graphSlice.js","components/TopMenu/SolveControl.js","components/TopMenu/GeneratorControl.js","components/GraphArea/Tile.js","components/TopMenu/TopMenu.js","components/GraphArea/GraphArea.js","components/ControlsMenu/ControlsMenu.js","App.js","logic/redux/store.js","index.js"],"names":["generators","graphData","generationData","start","goal","vertices","walls","firstRun","queue","running","deltaWalls","deltaHoles","forEach","v","push","data","value","Math","floor","random","length","leftOuts","filter","n","neighbors","reduce","res","n2","includes","sort","a","b","l","pop","tmp","currentNode","nodeNeighbors","neighbor","secondNeighbor","Random","DFS","filteredNeighbors","currentHead","shift","solvers","BFS","graphState","edges","visited","parentDict","tmpQueue","currentVertex","goalNode","indexOf","updatedQueue","getMazeGenerators","names","getSolverNames","generateGraph","nx","ny","r","c","id","undefined","removeEdge","e","node","restoreEdge","step","state","paused","drawPath","pathTile","type","f","algorithms","solve","current","placeStart","action","payload","oldVal","placeEnd","GraphData","placeNode","generate","extraParams","setIntervalId","intervalId","pause","reset","resume","clear","updateSpeed","solveSpeed","wallATile","removeAWall","setAlgorithm","algorithmDict","generateMaze","w","updateGraph","randomStart","graphSlice","createSlice","name","initialState","end","solveArr","reducers","graphReducer","actions","SolveControl","props","selectedSolver","useSelector","graph","runSpeed","runSolver","oldTimeout","dispatch","useDispatch","delay","clearInterval","setInterval","solveHelper","className","FormControl","variant","InputLabel","Select","label","onChange","target","map","MenuItem","key","Button","color","onClick","currentGenerator","runGenerator","generateHelper","getCurrentCSS","cls","toggleWall","Tile","cellState","styles","width","height","style","onMouseEnter","buttons","onPointerDown","GeneratorControl","GraphArea","updateSizes","graphArea","document","getElementById","graphW","clientWidth","graphH","clientHeight","columns","TILE","rows","tileW","tileH","setState","onLoad","getTiles","tiles","cells","this","Component","connect","vertex","Typography","gutterBottom","Slider","onChangeCommitted","defaultValue","min","max","aria-labelledby","valueLabelDisplay","valueLabelFormat","marks","App","configureStore","reducer","middleware","getDefaultMiddleware","immutableCheck","serializableCheck","ReactDOM","render","StrictMode","store"],"mappings":"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","file":"static/js/main.bb80f7ea.chunk.js","sourcesContent":["export default function (graphData, generationData) {\r\n  let { start, goal, vertices } = graphData;\r\n  let deltaWalls = [],\r\n    deltaHoles = [];\r\n  vertices.forEach((v) => {\r\n    if (Math.random() > 0.7 && v !== start && v !== goal) deltaWalls.push(v);\r\n  });\r\n  return { running: false, deltaHoles, deltaWalls, generationData };\r\n}\r\n","import BFS from \"./solvers/BFS\";\r\nimport DFS from \"./solvers/DFS\";\r\nimport Random from \"./maze/Random\";\r\nimport DFSGenerate from \"./maze/DFS\";\r\nimport Prim from \"./maze/Prim\";\r\n// import Recursive from \"./maze/Recursive\";\r\n\r\nconst generators = { \"Prim's\": Prim, Random, DFS: DFSGenerate };\r\n\r\nconst solvers = {\r\n  BFS,\r\n  DFS,\r\n};\r\n\r\nfunction getMazeGenerators() {\r\n  let names = [];\r\n  for (let n in generators) names.push(n);\r\n  return names;\r\n}\r\n\r\nfunction getSolverNames() {\r\n  let names = [];\r\n  for (let n in solvers) names.push(n);\r\n  return names;\r\n}\r\n\r\nexport { getMazeGenerators, getSolverNames, solvers, generators };\r\n","export default function (graphData, generationData) {\r\n  let { start, goal, vertices, walls } = graphData;\r\n  let { firstRun, queue, running } = generationData;\r\n  let deltaWalls = [];\r\n  let deltaHoles = [];\r\n  if (firstRun) {\r\n    //Fill all the maze with walls\r\n    vertices.forEach((v) => {\r\n      if (v !== start && v !== goal) {\r\n        deltaWalls.push(v);\r\n        graphData.data[v].value = Math.floor(Math.random() * 100); //better than just selecting random queue\r\n      }\r\n    });\r\n    generationData.firstRun = false;\r\n    generationData.queue = [start]; //start from the start\r\n  } else {\r\n    if (queue.length === 0) {\r\n      // add the unreachable walls with an extra hole\r\n      let leftOuts = walls.filter((n) => graphData.data[n].neighbors.reduce((res, n2) => res && walls.includes(n2), true));\r\n      leftOuts.sort((a, b) => graphData.data[a].value - graphData.data[b].value);\r\n\r\n      if (leftOuts.length !== 0) {\r\n        let l = leftOuts.pop();\r\n        queue.push(l);\r\n        let tmp = graphData.data[l].neighbors.filter((n) => walls.includes(n) && !queue.includes(n)); //possible extra holes\r\n        queue.push(tmp[Math.floor(Math.random() * tmp.length)]);\r\n      } else return { running: false, deltaWalls: [], deltaHoles: [], generationData };\r\n    }\r\n    let currentNode = queue.pop();\r\n    let nodeNeighbors = graphData.data[currentNode].neighbors;\r\n    //filter out\r\n    nodeNeighbors = nodeNeighbors.filter((neighbor) => !queue.includes(neighbor) && walls.includes(neighbor));\r\n    nodeNeighbors = nodeNeighbors.filter((neighbor) =>\r\n      graphData.data[neighbor].neighbors.reduce((res, secondNeighbor) => {\r\n        if (secondNeighbor === goal) return true;\r\n        if (secondNeighbor === currentNode) return res; //skip the father node\r\n        if (queue.includes(secondNeighbor) || !walls.includes(secondNeighbor)) return false; //if it has a neighbor who is in queue or a wall - don't add it\r\n        return res;\r\n      }, true)\r\n    );\r\n    //\r\n    //add to queue\r\n    generationData.queue = [...queue.filter((n) => n !== currentNode), ...nodeNeighbors];\r\n    generationData.queue.sort((a, b) => graphData.data[a].value - graphData.data[b].value);\r\n\r\n    //make a hole\r\n    deltaHoles = [...deltaHoles, currentNode];\r\n  }\r\n  return { running, deltaHoles, deltaWalls, generationData };\r\n}\r\n","export default function (graphData, generationData) {\r\n  let { start, goal, vertices, walls } = graphData;\r\n  let { firstRun, queue, running } = generationData;\r\n  let deltaWalls = [];\r\n  let deltaHoles = [];\r\n  if (firstRun) {\r\n    vertices.forEach((v) => {\r\n      if (v !== start && v !== goal) deltaWalls.push(v);\r\n    });\r\n    generationData.firstRun = false;\r\n    generationData.queue = [start];\r\n  } else {\r\n    let neighbors, filteredNeighbors, currentHead;\r\n    do {\r\n      if (queue.length === 0) return { running: false, deltaWalls: [], deltaHoles: [], generationData };\r\n      currentHead = queue.shift();\r\n      walls = walls.filter((n) => n !== currentHead);\r\n      neighbors = graphData.data[currentHead].neighbors;\r\n      filteredNeighbors = neighbors.filter((n) => walls.includes(n));\r\n    } while (neighbors.length - filteredNeighbors.length > 1 && !neighbors.includes(goal));\r\n\r\n    neighbors.sort((a, b) => 0.75 - Math.random()); //randomize the DFS but not too much\r\n    queue = [...neighbors, ...queue.filter((n) => !neighbors.includes(n))];\r\n    deltaHoles = [...deltaHoles, currentHead];\r\n    generationData = { ...generationData, queue };\r\n  }\r\n  return { running, deltaHoles, deltaWalls, generationData };\r\n}\r\n","export default function BFS(graphState) {\r\n  let { edges, queue, visited, parentDict, running, goal } = graphState;\r\n  if (queue.length === 0) return graphState; // if no path\r\n  let tmpQueue = [...queue]; // every step will include all the level nodes\r\n  queue = [];\r\n  while (tmpQueue.length > 0) {\r\n    let currentVertex = tmpQueue.pop(); //get the next one (fifo)\r\n    // let currentVertex = queue.pop(); //get the next one (fifo)\r\n    let neighbors = edges[currentVertex];\r\n    neighbors = neighbors.filter((v) => !visited.includes(v) && !queue.includes(v));\r\n    neighbors.forEach((v) => (parentDict[v] = currentVertex));\r\n    queue = [...neighbors, ...queue];\r\n    visited.push(currentVertex);\r\n    if (neighbors.includes(goal)) {\r\n      let goalNode = neighbors[neighbors.indexOf(goal)];\r\n      parentDict[goalNode] = currentVertex;\r\n      running = false;\r\n    }\r\n  }\r\n  return { edges, queue, visited, parentDict, running, goal };\r\n}\r\n","export default function DFS(graphState) {\r\n  let { edges, queue, visited, parentDict, running, goal } = graphState;\r\n  if (queue.length === 0) return { ...graphState, running: false }; // if no path\r\n  let currentVertex = queue.shift(); //get the next one (lifo)\r\n  let neighbors = edges[currentVertex];\r\n  neighbors = neighbors.filter((v) => !visited.includes(v));\r\n  let updatedQueue = neighbors.filter((v) => queue.includes(v));\r\n  if (updatedQueue.length > 0) queue = queue.filter((v) => !updatedQueue.includes(v)); //make room for the updated nodes\r\n  neighbors.forEach((v) => (parentDict[v] = currentVertex));\r\n\r\n  queue = [...neighbors, ...queue];\r\n  visited.push(currentVertex);\r\n  if (neighbors.includes(goal)) {\r\n    let goalNode = neighbors[neighbors.indexOf(goal)];\r\n    parentDict[goalNode] = currentVertex;\r\n    running = false;\r\n  }\r\n  return { edges, queue, visited, parentDict, running, goal };\r\n}\r\n","function generateGraph(nx, ny) {\r\n  let vertices = [];\r\n  let edges = {};\r\n  for (let r = 0; r < ny; r++)\r\n    for (let c = 0; c < nx; c++) {\r\n      let id = nx * r + c;\r\n      vertices.push(id); //Add ID first\r\n      if (edges[id] === undefined) edges[id] = [];\r\n      if (id - 1 >= 0 && (id - 1) % nx <= id % nx) {\r\n        edges[id].push(id - 1);\r\n        edges[id - 1].push(id);\r\n      }\r\n      if (id - nx >= 0) {\r\n        edges[id].push(id - nx);\r\n        edges[id - nx].push(id);\r\n      }\r\n    }\r\n\r\n  return { vertices, edges };\r\n}\r\n\r\nconst removeEdge = (e, node) => {\r\n  let edges = { ...e };\r\n  let neighbors = edges[node];\r\n  neighbors.forEach((n) => {\r\n    edges[n] = edges[n].filter((v) => v !== node);\r\n  });\r\n  edges[node] = [];\r\n  return edges;\r\n};\r\n\r\nconst restoreEdge = (e, neighbors, walls, node) => {\r\n  let edges = { ...e };\r\n\r\n  neighbors.forEach((n) => {\r\n    if (!walls.includes(n)) edges[n] = [...edges[n], node];\r\n  });\r\n  edges[node] = [...neighbors.filter((n) => !walls.includes(n))];\r\n  return edges;\r\n};\r\n\r\nexport { generateGraph, removeEdge, restoreEdge };\r\n","/*\r\n    graphData: {\r\n      vertices: [],\r\n      edges: [],\r\n      data: {},\r\n      parentDict: {},\r\n      visited: [],\r\n      queue: [],\r\n      goal: -1,\r\n      running: false,\r\n    },\r\n    solveSpeed: 200,\r\n    wall: [],\r\n    start: 128,\r\n    end: -1,\r\n    algorithms: {\r\n      solve: getSolverNames()[0],\r\n      generate: undefined,\r\n      solveArr: getSolverNames(),\r\n    },\r\n  },\r\n*/\r\n\r\nimport { solvers, generators } from \"../../AlgorithmManager\";\r\nimport { removeEdge, restoreEdge } from \"../../GraphLogic\";\r\nexport default {\r\n  step: (state) => {\r\n    if (state.paused) return;\r\n    if (state.graphData.queue.length === 0) state.graphData.running = false;\r\n    //draw path at the end\r\n    if (state.graphData.drawPath) {\r\n      if (state.graphData.queue.length > 0) {\r\n        let pathTile = state.graphData.queue.pop();\r\n        if (state.graphData.data[pathTile].type === \"visited\") state.graphData.data[pathTile].type = \"path\";\r\n      }\r\n      return;\r\n    }\r\n    ///////////////////////\r\n    let f = solvers[state.algorithms.solve];\r\n    let res = f(state.graphData);\r\n\r\n    if (!res.running) res = { ...res, running: true, drawPath: true };\r\n    state.graphData = { ...state.graphData, ...res };\r\n    // when search is finished//////////\r\n    if (res.drawPath) {\r\n      state.graphData.queue = []; //empty it and it will be repurposed for the path\r\n      if (state.graphData.goal !== -1 && state.graphData.parentDict[state.graphData.goal] !== undefined) {\r\n        let current = state.graphData.goal;\r\n        while (state.graphData.parentDict[current] !== undefined) {\r\n          state.graphData.queue = [...state.graphData.queue, current];\r\n          current = state.graphData.parentDict[current];\r\n        }\r\n      }\r\n    }\r\n    /////////////////////\r\n    //change each cell type to visited if visited (duplication will not affect performance)\r\n    state.graphData.visited.forEach((v) => {\r\n      if (state.graphData.data[v].type === \"\") state.graphData.data[v].type = \"visited\";\r\n    });\r\n  },\r\n\r\n  placeStart: (state, action) => {\r\n    let id = action.payload;\r\n    let oldVal = state.graphData.data[id];\r\n    state.graphData.start = id;\r\n    state.graphData.data[id] = { ...oldVal, type: \"start\" };\r\n  },\r\n\r\n  placeEnd: (state, action) => {\r\n    let id = action.payload;\r\n    let oldVal = state.graphData.data[id];\r\n    state.GraphData.goal = id;\r\n    state.graphData.data[id] = { ...oldVal, type: \"end\" };\r\n  },\r\n  placeNode: (state, action) => {\r\n    let { type, id } = action.payload.id;\r\n    let oldVal = state.graphData.data[id];\r\n    state[type] = id;\r\n    state.graphData.data[id] = { ...oldVal, type };\r\n  },\r\n\r\n  solve: (state) => {\r\n    state.graphData.running = true;\r\n  },\r\n  generate: (state) => {\r\n    state.generationData = { extraParams: {}, running: true, firstRun: true, queue: [state.graphData.start] };\r\n  },\r\n  setIntervalId: (state, action) => {\r\n    let { type, value } = action.payload;\r\n    state.intervalId[type] = value;\r\n  },\r\n  pause: (state) => {\r\n    state.paused = true;\r\n  },\r\n  reset: (state) => {\r\n    state.graphData.vertices.forEach((v) => {\r\n      let { type } = state.graphData.data[v];\r\n      if (type !== \"start\" && type !== \"end\" && type !== \"wall\")\r\n        state.graphData.data[v] = { ...state.graphData.data[v], type: \"\", value: 0 };\r\n    });\r\n    state.graphData = {\r\n      ...state.graphData,\r\n      running: false,\r\n      drawPath: false,\r\n      queue: [state.graphData.start],\r\n      visited: [],\r\n      parentDict: [],\r\n    };\r\n    state.paused = false;\r\n  },\r\n  resume: (state) => {\r\n    state.paused = false;\r\n  },\r\n  clear: (state) => {\r\n    state.graphData.walls = [];\r\n    state.graphData.vertices.forEach((v) => {\r\n      state.graphData.edges[v] = state.graphData.data[v].neighbors;\r\n      if (state.graphData.data[v].type !== \"start\" && state.graphData.data[v].type !== \"end\") state.graphData.data[v].type = \"\";\r\n    });\r\n  },\r\n  updateSpeed: (state, action) => {\r\n    state.solveSpeed = action.payload;\r\n  },\r\n  wallATile: (state, action) => {\r\n    let { type } = state.graphData.data[action.payload];\r\n    if (type !== \"\" || state.graphData.walls.includes(action.payload)) return;\r\n    state.graphData.walls.push(action.payload);\r\n    state.graphData.data[action.payload].type = \"wall\";\r\n    state.graphData.edges = { ...removeEdge(state.graphData.edges, action.payload) };\r\n  },\r\n\r\n  removeAWall: (state, action) => {\r\n    let { type, neighbors } = state.graphData.data[action.payload];\r\n    if (type !== \"wall\") return;\r\n    state.graphData.walls = state.graphData.walls.filter((v) => v !== action.payload);\r\n    state.graphData.data[action.payload].type = \"\";\r\n    state.graphData.edges = { ...restoreEdge(state.graphData.edges, neighbors, state.graphData.walls, action.payload) };\r\n  },\r\n\r\n  setAlgorithm: (state, action) => {\r\n    let { value, type } = action.payload;\r\n    let algorithmDict;\r\n    switch (type) {\r\n      case \"solve\":\r\n        algorithmDict = solvers;\r\n        break;\r\n      default:\r\n        algorithmDict = generators;\r\n    }\r\n    if (algorithmDict[value] !== undefined) state.algorithms[type] = value;\r\n  },\r\n\r\n  generateMaze: (state) => {\r\n    let f = generators[state.algorithms.generate];\r\n    let { deltaWalls, deltaHoles, running, generationData, extraParams } = f(state.graphData, state.generationData);\r\n    state.graphData.walls = [...state.graphData.walls.filter((v) => !deltaHoles.includes(v)), ...deltaWalls];\r\n    deltaWalls.forEach((w) => {\r\n      if (w === state.graphData.start || w === state.graphData.goal) return;\r\n      state.graphData.data[w].type = \"wall\";\r\n      state.graphData.edges = { ...removeEdge(state.graphData.edges, w) };\r\n    });\r\n\r\n    deltaHoles.forEach((n) => {\r\n      if (n === state.graphData.start || n === state.graphData.goal) return;\r\n\r\n      state.graphData.data[n].type = \"\";\r\n      state.graphData.edges = {\r\n        ...restoreEdge(state.graphData.edges, state.graphData.data[n].neighbors, state.graphData.walls, n),\r\n      };\r\n    });\r\n    state.generationData = { ...generationData, running, extraParams };\r\n  },\r\n\r\n  updateGraph: (state, action) => {\r\n    let { vertices, edges } = action.payload;\r\n    state.graphData.vertices = vertices;\r\n    let randomStart = Math.floor(Math.random() * vertices.length); //temp\r\n\r\n    state.graphData.start = randomStart;\r\n    state.graphData.data[randomStart] = { type: \"start\", neighbors: edges[randomStart], value: 0 };\r\n    state.graphData.queue = [randomStart];\r\n    randomStart = Math.floor(Math.random() * vertices.length); //temp\r\n    state.graphData.goal = randomStart;\r\n    state.graphData.data[randomStart] = { type: \"end\", neighbors: edges[randomStart], value: 0 };\r\n    state.graphData.goal = randomStart;\r\n    state.graphData.edges = edges;\r\n    vertices.forEach((v) => {\r\n      if (state.graphData.data[v] === undefined) state.graphData.data[v] = { type: \"\", neighbors: edges[v], value: 0 };\r\n    });\r\n  },\r\n};\r\n","import { createSlice } from \"@reduxjs/toolkit\";\r\nimport { getSolverNames, getMazeGenerators } from \"../AlgorithmManager\";\r\nimport graphReducer from \"./reducers/reducers\";\r\nexport const graphSlice = createSlice({\r\n  name: \"graph\",\r\n  initialState: {\r\n    graphData: {\r\n      vertices: [],\r\n      edges: [],\r\n      data: {},\r\n      parentDict: {},\r\n      visited: [],\r\n      queue: [],\r\n      drawPath: false,\r\n      goal: -1,\r\n      start: -1,\r\n      running: false,\r\n      walls: [],\r\n    },\r\n    generationData: {\r\n      running: false,\r\n      intervalId: undefined,\r\n      queue: [],\r\n      firstRun: true,\r\n      extraParams: {},\r\n    },\r\n    solveSpeed: 200,\r\n    start: 128,\r\n    end: -1,\r\n    paused: false,\r\n    intervalId: {\r\n      solve: undefined,\r\n      generate: undefined,\r\n    },\r\n    algorithms: {\r\n      solve: getSolverNames()[0],\r\n      generate: getMazeGenerators()[0],\r\n      solveArr: getSolverNames(),\r\n    },\r\n  },\r\n  reducers: graphReducer,\r\n});\r\n\r\nexport const {\r\n  step,\r\n  solve,\r\n  generate,\r\n  reset,\r\n  pause,\r\n  resume,\r\n  clear,\r\n  wallATile,\r\n  generateMaze,\r\n  placeStart,\r\n  updateGraph,\r\n  removeAWall,\r\n  updateSpeed,\r\n  setIntervalId,\r\n  setAlgorithm,\r\n} = graphSlice.actions;\r\n\r\nexport default graphSlice.reducer;\r\n","import React from \"react\";\r\nimport { FormControl, InputLabel, Select, Button, MenuItem } from \"@material-ui/core\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { solve, reset, step, setAlgorithm, setIntervalId } from \"../../logic/redux/graphSlice\";\r\nimport { getSolverNames } from \"../../logic/AlgorithmManager\";\r\n\r\nconst getOptionsFromArray = (arr) => {\r\n  return arr.map((v) => (\r\n    <MenuItem key={v} value={v}>\r\n      {v}\r\n    </MenuItem>\r\n  ));\r\n};\r\n\r\nconst solveHelper = (dispatch, delay, runSolver, oldTimeout) => {\r\n  clearInterval(oldTimeout);\r\n  if (!runSolver) return;\r\n  let intervalId = setInterval(() => {\r\n    dispatch(step());\r\n  }, delay);\r\n  return intervalId;\r\n};\r\n\r\nconst SolveControl = (props) => {\r\n  const selectedSolver = useSelector((state) => state.graph.algorithms.solve);\r\n  const runSpeed = useSelector((state) => state.graph.solveSpeed);\r\n  const runSolver = useSelector((state) => state.graph.graphData.running);\r\n  const oldTimeout = useSelector(\r\n    (state) => state.graph.intervalId.solve,\r\n    () => true\r\n  );\r\n  const dispatch = useDispatch();\r\n  let intervalId = solveHelper(dispatch, runSpeed, runSolver, oldTimeout);\r\n  dispatch(setIntervalId({ type: \"solve\", value: intervalId }));\r\n\r\n  return (\r\n    <div className=\"sub-section maze-solvers\">\r\n      <FormControl variant=\"outlined\">\r\n        <InputLabel>Solvers</InputLabel>\r\n        <Select\r\n          name=\"solvers\"\r\n          id=\"solvers\"\r\n          value={selectedSolver}\r\n          label=\"Solvers\"\r\n          onChange={(e) => {\r\n            dispatch(setAlgorithm({ value: e.target.value, type: \"solve\" }));\r\n          }}\r\n        >\r\n          {getOptionsFromArray(getSolverNames())}\r\n        </Select>\r\n      </FormControl>\r\n      <Button\r\n        variant=\"contained\"\r\n        color=\"primary\"\r\n        onClick={(e) => {\r\n          dispatch(reset());\r\n          dispatch(solve());\r\n        }}\r\n      >\r\n        Solve\r\n      </Button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SolveControl;\r\n","import React from \"react\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { getMazeGenerators } from \"../../logic/AlgorithmManager\";\r\nimport { Button, Select, MenuItem, FormControl, InputLabel } from \"@material-ui/core\";\r\nimport { setAlgorithm, generateMaze, clear, generate, setIntervalId, reset } from \"../../logic/redux/graphSlice\";\r\nconst getOptionsFromArray = (arr) => {\r\n  return arr.map((v) => (\r\n    <MenuItem key={v} value={v}>\r\n      {v}\r\n    </MenuItem>\r\n  ));\r\n};\r\n\r\nconst generateHelper = (dispatch, runGenerator, oldTimeout) => {\r\n  clearInterval(oldTimeout);\r\n  if (!runGenerator) return;\r\n  let intervalId = setInterval(() => {\r\n    dispatch(generateMaze());\r\n  }, 10);\r\n  return intervalId;\r\n};\r\n\r\nexport default (props) => {\r\n  const currentGenerator = useSelector((state) => state.graph.algorithms.generate);\r\n  const runGenerator = useSelector((state) => state.graph.generationData.running);\r\n  const oldTimeout = useSelector(\r\n    (state) => state.graph.intervalId.generate,\r\n    () => true\r\n  );\r\n  const dispatch = useDispatch();\r\n  let intervalId = generateHelper(dispatch, runGenerator, oldTimeout);\r\n  dispatch(setIntervalId({ type: \"generate\", value: intervalId }));\r\n\r\n  return (\r\n    <div className=\"sub-section maze-generation\">\r\n      <FormControl variant=\"outlined\">\r\n        <InputLabel>Generators</InputLabel>\r\n        <Select\r\n          name=\"generators\"\r\n          id=\"generators\"\r\n          value={currentGenerator}\r\n          label=\"Generators\"\r\n          onChange={(e) => {\r\n            dispatch(setAlgorithm({ value: e.target.value, type: \"generate\" }));\r\n          }}\r\n        >\r\n          {getOptionsFromArray(getMazeGenerators())}\r\n        </Select>\r\n      </FormControl>\r\n      <Button\r\n        variant=\"contained\"\r\n        color=\"secondary\"\r\n        onClick={(e) => {\r\n          dispatch(reset());\r\n          dispatch(clear());\r\n          dispatch(generate());\r\n        }}\r\n      >\r\n        Generate\r\n      </Button>\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport \"./Tile.css\";\r\nimport { useSelector, useDispatch } from \"react-redux\";\r\nimport { wallATile, removeAWall } from \"../../logic/redux/graphSlice\";\r\nconst TILE = 25;\r\nconst getCurrentCSS = (type) => {\r\n  let cls = \"tile \";\r\n  switch (type) {\r\n    case \"start\":\r\n      return cls + \"tile-start\";\r\n    case \"end\":\r\n      return cls + \"tile-end\";\r\n    case \"visited\":\r\n      return cls + \"tile-visited\";\r\n    case \"current\":\r\n      return cls + \"tile-current\";\r\n    case \"path\":\r\n      return cls + \"tile-path\";\r\n    case \"wall\":\r\n      return cls + \"tile-wall\";\r\n    default:\r\n      return cls;\r\n  }\r\n};\r\nconst toggleWall = (dispatch, type, id) => {\r\n  switch (type) {\r\n    case \"wall\":\r\n      dispatch(removeAWall(id));\r\n      break;\r\n    default:\r\n      dispatch(wallATile(id));\r\n  }\r\n};\r\n\r\nconst Tile = (props) => {\r\n  const dispatch = useDispatch();\r\n  let cellState = useSelector((state) => state.graph.graphData.data[props.id]);\r\n  let styles = { width: TILE, height: TILE };\r\n  return (\r\n    <td\r\n      id={props.id}\r\n      key={props.id}\r\n      className={getCurrentCSS(cellState.type)}\r\n      style={styles}\r\n      onMouseEnter={(e) => {\r\n        if (e.buttons === 1) toggleWall(dispatch, cellState.type, props.id);\r\n      }}\r\n      onPointerDown={(e) => {\r\n        toggleWall(dispatch, cellState.type, props.id);\r\n      }}\r\n    ></td>\r\n  );\r\n};\r\n\r\nexport default Tile;\r\nexport { TILE };\r\n","import React from \"react\";\r\nimport \"./TopMenu.css\";\r\nimport SolveControl from \"./SolveControl\";\r\nimport GeneratorControl from \"./GeneratorControl\";\r\nimport { TILE } from \"../GraphArea/Tile\";\r\nexport default (props) => {\r\n  return (\r\n    <div className=\"top-menu\">\r\n      <GeneratorControl />\r\n\r\n      <SolveControl />\r\n\r\n        <ul className=\"sub-section legend\">\r\n          <li>\r\n            <p>Start</p>\r\n            <div style={{ width: TILE, height: TILE }} className=\"tile-start\"></div>\r\n          </li>\r\n          <li>\r\n            <p>Goal</p>\r\n            <div style={{ width: TILE, height: TILE }} className=\"tile-end\"></div>\r\n          </li>\r\n          <li>\r\n            <p>Wall</p>\r\n            <div style={{ width: TILE, height: TILE }} className=\"tile-wall\"></div>\r\n          </li>\r\n          <li>\r\n            <p>Path</p>\r\n            <div style={{ width: TILE, height: TILE }} className=\"tile-path\"></div>\r\n          </li>\r\n        </ul>\r\n      </div>\r\n  );\r\n};\r\n","import React, { Component } from \"react\";\r\nimport \"./GraphArea.css\";\r\nimport Tile, { TILE } from \"./Tile\";\r\nimport { connect } from \"react-redux\";\r\nimport { placeStart, updateGraph } from \"../../logic/redux/graphSlice\";\r\nimport { generateGraph } from \"../../logic/GraphLogic\";\r\n\r\nconst mapStateToProps = (state) => {\r\n  let vertices = state.graph.graphData.vertices;\r\n  return { vertices };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    placeStart: (vertex) => dispatch(placeStart(vertex)),\r\n    updateGraph: (nx, ny) => {\r\n      updateGraph(generateGraph(nx, ny));\r\n    },\r\n  };\r\n};\r\n\r\nclass GraphArea extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { rows: 0, columns: 0 };\r\n  }\r\n  componentDidMount() {\r\n    this.updateSizes();\r\n  }\r\n\r\n  updateSizes = () => {\r\n    let graphArea = document.getElementById(\"graph-area2\");\r\n    let graphW = graphArea.clientWidth;\r\n    let graphH = graphArea.clientHeight;\r\n    // let l = Math.sqrt((graphW * graphH) / 1200);\r\n    let l = TILE + 2; //+2 for border\r\n    let columns = Math.floor(graphW / l);\r\n    let rows = Math.floor(graphH / l);\r\n    let tileW = graphW / columns - 2;\r\n    let tileH = graphH / rows - 2;\r\n    this.setState({ graphW, graphH, columns, rows, tileW, tileH });\r\n    this.props.onLoad(columns, rows);\r\n    this.props.updateGraph(columns, rows);\r\n  };\r\n\r\n  getTiles = () => {\r\n    let tiles = [];\r\n    this.props.vertices.forEach((v) => {});\r\n    for (let r = 0; r < Math.floor(this.props.vertices.length / this.state.columns); r++) {\r\n      let cells = [];\r\n      for (let c = 0; c < Math.floor(this.props.vertices.length / this.state.rows); c++) {\r\n        let id = this.state.columns * r + c;\r\n        cells.push(<Tile id={id} key={id} />);\r\n      }\r\n      tiles.push(<tr key={\"row-\" + r}>{cells}</tr>);\r\n    }\r\n    return tiles;\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"graph-area\" id=\"graph-area2\">\r\n        <table>\r\n          <tbody>{this.getTiles()}</tbody>\r\n        </table>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(GraphArea);\r\n","import React from \"react\";\r\nimport \"./ControlsMenu.css\";\r\nimport { Slider, Button, Typography } from \"@material-ui/core\";\r\nimport { useDispatch, useSelector } from \"react-redux\";\r\nimport { updateSpeed, pause, reset, clear, resume } from \"../../logic/redux/graphSlice\";\r\nexport default (props) => {\r\n  const dispatch = useDispatch();\r\n  const paused = useSelector((state) => state.graph.paused);\r\n  const solveSpeed = useSelector((state) => state.graph.solveSpeed);\r\n  return (\r\n    <div className=\"controls-menu\">\r\n      <Button\r\n        variant=\"contained\"\r\n        onClick={(e) => {\r\n          if (paused) dispatch(resume());\r\n          else dispatch(pause());\r\n        }}\r\n      >\r\n        {paused ? \"Resume\" : \"Pause\"}\r\n      </Button>\r\n      <Button\r\n        variant=\"contained\"\r\n        onClick={(e) => {\r\n          dispatch(reset());\r\n        }}\r\n      >\r\n        Reset\r\n      </Button>\r\n      <Button\r\n        variant=\"contained\"\r\n        onClick={(e) => {\r\n          dispatch(reset());\r\n          dispatch(clear());\r\n        }}\r\n      >\r\n        Clear\r\n      </Button>\r\n      <div>\r\n        <Typography gutterBottom>Speed</Typography>\r\n        <Slider\r\n          onChangeCommitted={(e, v) => dispatch(updateSpeed(1010 - v))} //TODO: remove hard coded values\r\n          defaultValue={750}\r\n          step={50}\r\n          min={500}\r\n          max={1000}\r\n          aria-labelledby=\"discrete-slider\"\r\n          valueLabelDisplay=\"auto\"\r\n          valueLabelFormat={(v) => 1010 - v}\r\n          marks\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import React from \"react\";\r\nimport TopMenu from \"./components/TopMenu/TopMenu\";\r\nimport \"./App.css\";\r\nimport GraphArea from \"./components/GraphArea/GraphArea\";\r\nimport { generateGraph } from \"./logic/GraphLogic\";\r\nimport { useDispatch } from \"react-redux\";\r\nimport { updateGraph } from \"./logic/redux/graphSlice\";\r\nimport ControlsMenu from \"./components/ControlsMenu/ControlsMenu\";\r\n\r\nconst App = () => {\r\n  const dispatch = useDispatch();\r\n  return (\r\n    <div className=\"App\">\r\n      <TopMenu />\r\n      <GraphArea onLoad={(nx, ny) => dispatch(updateGraph(generateGraph(nx, ny)))} />\r\n      <ControlsMenu />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import { configureStore, getDefaultMiddleware } from \"@reduxjs/toolkit\";\r\nimport graphReducer from \"./graphSlice\";\r\nexport default configureStore({\r\n  reducer: {\r\n    graph: graphReducer,\r\n    middleware:getDefaultMiddleware({immutableCheck:false,serializableCheck:false})\r\n  },\r\n});\r\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport { Provider } from \"react-redux\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport store from \"./logic/redux/store\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <Provider store={store}>\r\n      <App />\r\n    </Provider>\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n"],"sourceRoot":""}